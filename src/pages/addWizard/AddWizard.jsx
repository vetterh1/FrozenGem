/* eslint-disable react-hooks/rules-of-hooks */

// React
import React, { useEffect } from "react";
import { withRouter } from "react-router";
import { Redirect } from "react-router";
// Redux
import { connect } from "react-redux";
import { itemsActions } from "_actions/itemsActions";
import { notifierActions } from "_actions/notifierActions";
import { characteristicsServices } from "_services/characteristicsServices";
// HOC
import { injectIntl } from "react-intl";
import { makeStyles } from '@material-ui/core/styles';
// MUI
import Container from '@material-ui/core/Container';
// Components
import StepWizard from "react-step-wizard";
import WizCharacteristicsSelection from "pages/utils/WizCharacteristicsSelection";
import WizTextOrDateSelection from "pages/utils/WizTextOrDateSelection";
import Stepper from "pages/utils/Stepper";



const useStyles = makeStyles(theme => ({
  container: {
    display: "flex",
    flexDirection: "column",
    flex: "1 1 auto",
    padding: (density) => theme.spacing(density <= 2 ? 4 : 5),
    [theme.breakpoints.down('xs')]: {
      padding: (density) => theme.spacing(density === 1 ? 2 : 3),
    },  
  },
}));

const AddWizard = ({
  // From Redux:
  density,
  loggedIn,
  language,
  characteristics,
  addItem,
  addIntlNotifier,
  // From other HOC:
  intl,
  history
}) => {
  const emptyItem = {
    id: null,
    category: null,
    categoryName: "",
    categoryDetails: [],
    detailsArray: [],
    container: null,
    containerName: "",
    containerColors: [],
    color: null,
    size: null,
    freezer: null,
    location: null,
    description: "",
    expirationDate: null,
    expirationInMonth: 0,
    pictureName: null,
    code: null
  };

  const [returnHome, setReturnHome] = React.useState(false);

  useEffect(() => {
    console.log("> Router", history.action, history.location);
    if (history.action === "POP" && history.location.hash === "#expirationDate")
      setReturnHome(true);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [history.location.key]);

  const [item, setItemValues] = React.useState(emptyItem);

  const classes = useStyles(density);

  if (returnHome) {
    console.debug("[>>> Add #expirationDate ------>>>----- /dashboard >>>] Reason: back from Details not allowed!");
    return <Redirect to="/dashboard" />;
  }


  const _handleChangeWithServerSave = async updates => {
    // First, save to get the code & id
    try {
      const itemUpdated = await addItem({ ...item, ...updates });
      console.debug("_handleChangeWithServerSave - itemUpdated ", itemUpdated);

      // Then update state with code & id generated by the server & locqtion!
      handleChange(
        { code: itemUpdated.code, id: itemUpdated.id, ...updates },
        false
      );
      // returns the id so the caller can go to this detailed page:
      return itemUpdated.id;
    } catch (error) {
      console.error("AddWizard._handleChangeWithServerSave error: ", error);
      addIntlNotifier("item.add.error", "error");
    }
    return null;
  };

  const handleBack = async (updates, updateServer = false) => {
    await handleChange(updates, updateServer);
    return 1;
  };


  // Set the received value in the state
  // (replacing any existing one)
  const handleChange = async (updates, updateServer = false) => {
    // Update the item with the new values
    setItemValues({ ...item, ...updates });

    if (updateServer) {
      try {
        const itemUpdated = await itemsActions.updateItem(item.id, updates);
        handleChange({ code: itemUpdated.code });
      } catch (error) {
        console.error("AddWizard.handleChange error: ", error);
        addIntlNotifier("item.add.error", "error");
        return null;
      }
    }
    return 1;
  };


  const handleMultiselectionChange = name => async (
    updates,
    updateServer = false
  ) => {
    const updatedValue = updates[name];
    if (updatedValue) {
      const existingValues = item[name];
      console.debug("existingValues", existingValues);
      let alreadyExists = false;
      const undefinedExistingValues =
        !existingValues || existingValues === undefined;
      if (!undefinedExistingValues && existingValues.length > 0)
        alreadyExists = existingValues.find(
          valueInList => valueInList === updatedValue
        );

      // Add the received value to the state value lists if it does not exist yet
      // If it already exists: remove it (toggle action)
      let newValues;
      if (alreadyExists) {
        newValues = existingValues.filter(
          valueInList => valueInList !== updatedValue
        );
      } else {
        if (!undefinedExistingValues)
          newValues = [...existingValues, updatedValue];
        else newValues = [updatedValue];
      }
      await handleChange({ ...updates, [name]: newValues }, updateServer);
    }
    return null;
  };


  const handleNextFromCategory = async (updates, updateServer = false) => {
    let categoryDetails = [];
    let categoryName = "";

    // When category is selected, get it's details:
    const category = updates["category"];
    if (category) {
      categoryName = !characteristics.categories
        ? "item"
        : characteristics.categories
            .find(oneCategory => oneCategory.id2 === category)
            .name[language].toLowerCase();
      categoryDetails = characteristics.details.filter(detail =>
        detail.parents.find(
          oneParent => oneParent === "all" || oneParent === category
        )
      );
    }
    await handleChange(
      { ...updates, categoryName, categoryDetails },
      updateServer
    );
    return 1;
  };


  const handleDetailsChange = async (updates, updateServer = false) => {
    await handleMultiselectionChange("detailsArray")(updates, updateServer);
    return null;
  };


  //
  // Compute expiration date from now & category & details
  //
  const computeExpiration = () => {
    const defaultExpirationInMonths = characteristicsServices.getDefaultExpirationInMonths(
      item.category,
      item.detailsArray,
      characteristics
    );
    let expirationDateInDateForm = new Date();
    expirationDateInDateForm.setMonth(
      expirationDateInDateForm.getMonth() + defaultExpirationInMonths,
      1
    );
    console.debug(
      "computeExpiration - defaultExpirationInMonths: " +
        defaultExpirationInMonths +
        ", expirationDateInDateForm:",
      expirationDateInDateForm
    );
    return {
      expirationDate: expirationDateInDateForm.getTime(),
      expirationInMonth: defaultExpirationInMonths
    };
  };


  function monthDiff(d1, d2) {
    var months;
    months = (d2.getFullYear() - d1.getFullYear()) * 12;
    months -= d1.getMonth() + 1;
    months += d2.getMonth();
    return months <= 0 ? 0 : months;
  }


  const getMonthsBetweenNowAndDate = dateInMs => {
    const diffInMonths = monthDiff(new Date(), new Date(dateInMs));
    console.debug("getMonthsBetweenNowAndDate diffInMonths:", diffInMonths);
    return diffInMonths;
  };


  const handleNextFromDetails = async (updateServer = false) => {
    const updatesComputed = computeExpiration();
    await handleChange({ ...updatesComputed }, updateServer);
    return 1;
  };


  const handleNextFromDateWithServerSave = async updates => {
    const expirationDateInMs = updates["expirationDate"];
    if (expirationDateInMs) {
      const monthsBetweenNowAndDate = getMonthsBetweenNowAndDate(
        expirationDateInMs
      );
      const id = await _handleChangeWithServerSave({
        expirationDate: expirationDateInMs,
        expirationInMonth: monthsBetweenNowAndDate
      });
      history.push(`/new/${id}`);
    }
    return null;
  };


  if (!loggedIn) {
    console.debug("[>>> AddWizard ------>>>----- / >>>] Reason: not logged in");
    return <Redirect to="/" />;
  }


  console.debug("----------> item : ", item);

  
  return (
    <Container maxWidth="xl" className={classes.container}>
      <StepWizard
        isHashEnabled
        transitions={{}}
        className={"flex-normal-height flex-direction-column"}
        classNameWrapper={"flex-normal-height flex-direction-column"}
        nav={<Stepper />}
      >
        <WizCharacteristicsSelection
          density={density}
          hashKey={"category"}
          name="category"
          title={intl.formatMessage({ id: "add.category.title" })}
          handleChange={handleNextFromCategory}
          items={characteristics.categories}
          preselectedItems={item.category}
          showNavigation
          backDisabled
        />
        <WizCharacteristicsSelection
          density={density}
          hashKey={"details"}
          name="detailsArray"
          title={intl.formatMessage(
            { id: "add.details.title" },
            { category: item.categoryName }
          )}
          handleChange={handleDetailsChange}
          handleNext={handleNextFromDetails}
          handleBack={handleBack}
          items={item.categoryDetails}
          preselectedItems={item.detailsArray}
          multiselection
          showNavigation
          defaultIconName={"category" + item.category}
        />
        <WizTextOrDateSelection
          hashKey={"description"}
          name="description"
          title={intl.formatMessage({ id: "add.description.title" })}
          help={intl.formatMessage({ id: "add.description.help" })}
          handleBack={handleBack}
          handleNext={handleChange}
          initialValue={item.description}
          showNavigation
        />
        <WizCharacteristicsSelection
          density={density}
          hashKey={"size"}
          name="size"
          title={intl.formatMessage({ id: "add.size.title" })}
          handleChange={handleChange}
          handleBack={handleBack}
          items={characteristics.sizes}
          preselectedItems={item.size}
          showNavigation
        />
        <WizCharacteristicsSelection
          density={density}
          hashKey={"container"}
          name="container"
          title={intl.formatMessage({ id: "add.container.title" })}
          handleChange={handleChange}
          handleBack={handleBack}
          items={characteristics.containers}
          preselectedItems={item.container}
          showNavigation
        />
        {/* <WizCharacteristicsSelection
          density={density}
          hashKey={'color'}
          name='color'
          title={intl.formatMessage({id: 'add.color.title'}, {container: item.containerName})}
          handleChange={handleChange}
          handleBack={handleBack}
          items={item.containerColors}
          preselectedItems={item.color}
          showNavigation
        /> */}
        <WizTextOrDateSelection
          hashKey={"expirationDate"}
          name="expirationDate"
          isDate
          title={intl.formatMessage({ id: "add.date.title" })}
          help={intl.formatMessage({ id: "add.date.help" })}
          handleBack={handleBack}
          handleNext={handleNextFromDateWithServerSave}
          initialValue={item.expirationDate}
          showNavigation
        />
        {/* 

          <WizCharacteristicsSelection
          density={density}
            hashKey={'freezer'}
            name='freezer'
            title={intl.formatMessage({id: 'add.freezer.title'})}
            handleChange={handleChange}
            handleBack={handleBack}
            items={characteristics.freezers}
            preselectedItems={item.freezer}
            showNavigation
          />
          <WizCharacteristicsSelection
          density={density}
            hashKey={'location'}
            name='location'
            title={intl.formatMessage({id: 'add.location.title'})}
            handleChange={_handleChangeWithServerSave}
            handleBack={handleBack}
            items={characteristics.locations}
            preselectedItems={item.location}
            showNavigation
          />     
        <Results
          hashKey={"results"}
          item={item}
          onResetState={_resetState}
          handleAddPicture={_savePicture}
        />
      */}
      </StepWizard>
    </Container>
  );
};

function mapStateToProps(state, ownProps) {
  console.debug("AddWizard.mapStateToProps - ownProps, state=", ownProps, state);

  const {
    user: { loggedIn, language, density },
    characteristics
  } = state;
  return {
    loggedIn,
    language,
    density,
    characteristics
  };
}

const mapDispatchToProps = {
  addItem: itemsActions.addItem,
  addIntlNotifier: notifierActions.addIntlNotifier
};

const connectedAddWizard = connect(
  mapStateToProps,
  mapDispatchToProps
)(AddWizard);

export default withRouter(injectIntl(connectedAddWizard));
