import * as log from 'loglevel';
import React from 'react';
import { Redirect } from 'react-router'
import PropTypes from 'prop-types';
import { injectIntl, defineMessages } from "react-intl";
// import { defineMessages } from 'react-intl.macro';
import { withStyles } from '@material-ui/core/styles';
import { withUserInfo } from '../../auth/withUserInfo';
import { withItemCharacteristics } from '../../auth/withItemCharacteristics';
import { withItems } from '../../auth/withItems';
import CharacteristicsSelection from '../utils/CharacteristicsSelection';
import TextOrDateSelection from '../utils/TextOrDateSelection';
import Results from './Results';
import StepWizard from 'react-step-wizard';
import { withSnackbar } from 'notistack';


const styles = theme => ({
  button: {
    paddingRight: theme.spacing(1),
    paddingLeft: theme.spacing(2),
  },  
  divWizardPage: {
    marginTop: theme.spacing(2),
    display: "flex",
    flexDirection: "column",
    flex: "1 1 auto", 
  },
  maxHeight: {
    display: "flex",
    flexGrow: 1,
  },
  normalHeight: {
    display: "flex",
    flexGrow: 0,
  },  
});

const logAddWizard = log.getLogger('logAddWizard');
// loglevelServerSend(logAddWizard); // a setLevel() MUST be run AFTER this!
logAddWizard.setLevel('debug');
logAddWizard.debug('--> entering AddWizard.jsx');



const messages = defineMessages({ 
  error: {
    id: 'item.add.error',
    defaultMessage: 'Sorry, saving this item failed. Please try again...',
  },  
  successPicture: {
    id: 'camera.success',
    defaultMessage: 'Your photo has been added successfuly!',
  },  
  errorPicture: {
    id: 'camera.error',
    defaultMessage: 'Sorry, saving this picture failed. Please try again...',
  },
  titleCategory: {
    id: 'add.category.title',
    defaultMessage: 'What are you storing?',
  },  
  titleDetails: {
    id: 'add.details.title',
    defaultMessage: 'Tell us a little bit more about your {category}...',
  },
  titleName: {
    id: 'add.name.title',
    defaultMessage: 'Add a name (optional)',
  },
  helpName: {
    id: 'add.name.help',
    defaultMessage: 'To help you remember later what it is',
  },
  titleDate: {
    id: 'add.date.title',
    defaultMessage: 'Change expiration date (optional)',
  },  
  helpDate: {
    id: 'add.date.help',
    defaultMessage: 'Change the computed date here',
  },  
  titleContainer: {
    id: 'add.container.title',
    defaultMessage: 'What container are you using?',
  },
  titleColor: {
    id: 'add.color.title',
    defaultMessage: 'What color is your {container}?',
  },
  titleSize: {
    id: 'add.size.title',
    defaultMessage: 'How much quantity are you storing?',
  },
  titleFreezer: {
    id: 'add.freezer.title',
    defaultMessage: 'In which freezer are you storing it?',
  },  
  titleLocation: {
    id: 'add.location.title',
    defaultMessage: 'Where exactly do you store it?',
  },
});



const AddWizard = ({userInfo, items, itemCharacteristics, intl, enqueueSnackbar, closeSnackbar, classes}) => {

  const emptyEmpty = {
    id: null,
    category: null,
    categoryName: "",
    categoryDetails: [],
    details: [],
    container: null,
    containerName: "",
    containerColors: [],      
    color: null,
    size: null,
    freezer: null,
    location: null,
    name: "",
    expirationDate: null,
    expirationInMonth: 0,
    pictureName: null,
    thumbnailName: null,
    code: null,
  };
  const [item, setItemValues] = React.useState(emptyEmpty);
  // const [cameraDialogState, setCameraDialogState] = React.useState(false);
  

  const _resetState = () => setItemValues(emptyEmpty);

  
  const _handleChangeWithServerSave = async (updates) => {

    // First, update the item, but no server save!
    const nbStepsForward = await handleChange(updates, false);

    // then save...
    try {
      const itemUpdated = await items.saveItemToServer(item, userInfo);

      // Update state with code & id generated by the server:
      handleChange({code: itemUpdated.code, id: itemUpdated.id}, false);

    } catch (error) {
      console.error('AddWizard._handleChangeWithServerSave error: ' , error);
      const key =enqueueSnackbar(
       intl.formatMessage(messages.error), 
        {variant: 'error', anchorOrigin: {vertical: 'bottom',horizontal: 'center'}, onClick: () => {closeSnackbar(key);}}
      ); 
    }

    return nbStepsForward;
  }



  const handleBack = async (updates, updateServer = false) => {
    await handleChange(updates, updateServer);
    return 1;
  }

  const handleBackFromSize = async (updates, updateServer = false) => {
    await handleChange(updates, updateServer);
    return item.containerColors.length > 0 ? 1 : 2;
  }








  // Set the received value in the state 
  // (replacing any existing one)
  const handleChange = async (updates, updateServer = false) => {

    // Update the item with the new values
    setItemValues({ ...item, ...updates });

    if(updateServer) {
      try {
        const itemUpdated = await items.updateItemToServer(item.id , updates, userInfo);
        handleChange({code: itemUpdated.code})
      } catch (error) {
        console.error('AddWizard.handleChange error: ' , error);
        const key =enqueueSnackbar(
         intl.formatMessage(messages.error), 
          {variant: 'error', anchorOrigin: {vertical: 'bottom',horizontal: 'center'}, onClick: () => {closeSnackbar(key);}}
        ); 
        return null;
      }
    }
    return 1;
  }


  
  const handleMultiselectionChange = (name) => async (updates, updateServer = false) => {

    const updatedValue = updates[name];
    if(updatedValue){
      const existingValues = item[name];
      console.log("existingValues", existingValues)
      let alreadyExists = false;
      const undefinedExistingValues = !existingValues || existingValues === undefined;
      if(!undefinedExistingValues && existingValues.length > 0)
        alreadyExists = existingValues.find(valueInList => valueInList === updatedValue);

      // Add the received value to the state value lists if it does not exist yet
      // If it already exists: remove it (toggle action)
      let newValues;
      if(alreadyExists){
        newValues = existingValues.filter(valueInList => valueInList !== updatedValue);
      } else {
        if(!undefinedExistingValues)
          newValues = [...existingValues, updatedValue];
        else
          newValues = [updatedValue];
      }
      await handleChange({...updates, [name]: newValues}, updateServer);
    }
    return null;
  }







  const handleNextFromCategory = async (updates, updateServer = false) => {
    let categoryDetails = [];
    let categoryName = "";

    // When category is selected, get it's details:
    const category = updates['category'];
    if(category){
      categoryName = !itemCharacteristics.categories ? "item" : itemCharacteristics.categories.find(oneCategory => oneCategory.id2 === category).name[language].toLowerCase();
      categoryDetails = itemCharacteristics.details.filter(detail => detail.parents.find(oneParent => oneParent === 'all' || oneParent === category));
    }
    await handleChange({...updates, categoryName, categoryDetails}, updateServer);
    return 1;
  }

  


   
  const handleDetailsChange = async (updates, updateServer = false) => {
    await handleMultiselectionChange('details')(updates, updateServer);
    return null;
  }

  


  //
  // Compute expiration date from now & category & details
  //
  const computeExpiration =  () => {
    const defaultExpirationInMonths = itemCharacteristics.getDefaultExpirationInMonths(item.category, item.details);
    let expirationDateInDateForm = new Date();
    expirationDateInDateForm.setMonth(expirationDateInDateForm.getMonth() + defaultExpirationInMonths, 1);
    console.log("computeExpiration - defaultExpirationInMonths: " + defaultExpirationInMonths + ", expirationDateInDateForm:", expirationDateInDateForm);

    return ({ expirationDate: expirationDateInDateForm.getTime(), expirationInMonth: defaultExpirationInMonths});
  }


  function monthDiff(d1, d2) {
    var months;
    months = (d2.getFullYear() - d1.getFullYear()) * 12;
    months -= d1.getMonth() + 1;
    months += d2.getMonth();
    return months <= 0 ? 0 : months;
}


  const getMonthsBetweenNowAndDate = (dateInMs) => {
    const diffInMonths = monthDiff(new Date(), new Date(dateInMs));
    console.log("getMonthsBetweenNowAndDate diffInMonths:", diffInMonths);
    return diffInMonths;
  }





  const handleNextFromDetails = async (updateServer = false) => { 
    const updatesComputed = computeExpiration();
    await handleChange({...updatesComputed}, updateServer);
    return 1; 
  }
  



  const handleNextFromDate = async (updates, updateServer = false) => {
    const expirationDateInMs = updates['expirationDate'];
    if(expirationDateInMs){
      const monthsBetweenNowAndDate = getMonthsBetweenNowAndDate(expirationDateInMs);
      await handleChange({ expirationDate: expirationDateInMs, expirationInMonth: monthsBetweenNowAndDate}, updateServer);
    }
    return 1;
  }

  
  
  const handleNextFromContainer = async (updates, updateServer = false) => {
    let containerColors = [];
    let containerName = "";

    // If container changes, check if it has a color:
    const container = updates['container'];
    if(container){
      containerName = !itemCharacteristics.containers ? "container" : itemCharacteristics.containers.find(oneContainer => oneContainer.id2 === container).name[language].toLowerCase();
      containerColors = itemCharacteristics.colors.filter(color => color.parents.find(oneParent => oneParent === container));
    }

    await handleChange({...updates, containerName, containerColors}, updateServer);
    return containerColors.length > 0 ? 1 : 2;
  }






















 
  // Set the received value in the state 
  // (replacing any existing one)
  const _savePicture = async (pictureData, thumbnailData) => {

    try {
      const itemUpdated = await items.updatePictureItemToServer(item.id , pictureData, thumbnailData, userInfo);
      handleChange({pictureName: itemUpdated.pictureName, thumbnailName: itemUpdated.thumbnailName}, false);
      const key = enqueueSnackbar(
        intl.formatMessage(messages.successPicture), 
        {variant: 'success', anchorOrigin: {vertical: 'bottom',horizontal: 'center'}, onClick: () => {closeSnackbar(key);}}
      );  
    } catch (error) {
      console.error('AddWizard.handleChange error: ' , error);
      const key = enqueueSnackbar(
        intl.formatMessage(messages.errorPicture), 
        {variant: 'error', anchorOrigin: {vertical: 'bottom',horizontal: 'center'}, onClick: () => {closeSnackbar(key);}}
      ); 
    }
  }










  const { isAuthenticated, language } = userInfo;

  if (!isAuthenticated()) return <Redirect to='/' />;

  console.log("----------> item : ", item);


  return (
      <div className={classes.divWizardPage}>
        <StepWizard
          isHashEnabled 
          transitions={{}}
          className={"flex-normal-height flex-direction-column"} 
          classNameWrapper={'flex-normal-height flex-direction-column'}
        >
          <CharacteristicsSelection
            hashKey={'category'}
            name='category'
            title={intl.formatMessage(messages.titleCategory)}
            handleChange={handleNextFromCategory}
            items={itemCharacteristics.categories}
            preselectedItems={item.category}
            showNavigation
            backDisabled
          />
          <CharacteristicsSelection
            hashKey={'details'}
            name='details'
            title={intl.formatMessage(messages.titleDetails, {category: item.categoryName})}
            handleChange={handleDetailsChange}
            handleNext={handleNextFromDetails}
            handleBack={handleBack}
            items={item.categoryDetails}
            preselectedItems={item.details}
            multiselection
            showNavigation
            defaultIconName={"category"+item.category}
          />          
          <TextOrDateSelection
            hashKey={'name'}
            name='name'
            title={intl.formatMessage(messages.titleName)}
            help={intl.formatMessage(messages.helpName)}
            handleBack={handleBack}
            handleNext={handleChange}
            initialValue={item.name}
            showNavigation
          />
          <TextOrDateSelection
            hashKey={'expirationDate'}
            name='expirationDate'
            isDate
            title={intl.formatMessage(messages.titleDate)}
            help={intl.formatMessage(messages.helpDate)}
            handleBack={handleBack}
            handleNext={handleNextFromDate}
            initialValue={item.expirationDate}
            showNavigation
          />          
          <CharacteristicsSelection
            hashKey={'container'}
            name='container'
            title={intl.formatMessage(messages.titleContainer)}
            handleChange={handleNextFromContainer}
            handleBack={handleBack}
            items={itemCharacteristics.containers}
            preselectedItems={item.container}
            showNavigation
          />          
          <CharacteristicsSelection
            hashKey={'color'}
            name='color'
            title={intl.formatMessage(messages.titleColor, {container: item.containerName})}
            handleChange={handleChange}
            handleBack={handleBack}
            items={item.containerColors}
            preselectedItems={item.color}
            showNavigation
          />
          <CharacteristicsSelection
            hashKey={'size'}
            name='size'
            title={intl.formatMessage(messages.titleSize)}
            handleChange={handleChange}
            handleBack={handleBackFromSize}
            items={itemCharacteristics.sizes}
            preselectedItems={item.size}
            showNavigation
          />
          <CharacteristicsSelection
            hashKey={'freezer'}
            name='freezer'
            title={intl.formatMessage(messages.titleFreezer)}
            handleChange={handleChange}
            handleBack={handleBack}
            items={itemCharacteristics.freezers}
            preselectedItems={item.freezer}
            showNavigation
          />
          <CharacteristicsSelection
            hashKey={'location'}
            name='location'
            title={intl.formatMessage(messages.titleLocation)}
            handleChange={_handleChangeWithServerSave}
            handleBack={handleBack}
            items={itemCharacteristics.locations}
            preselectedItems={item.location}
            showNavigation
          />         
          <Results 
            hashKey={'results'}
            item = {item}
            onResetState={_resetState} 
            handleAddPicture={_savePicture}
          />
        </StepWizard>
      </div>
    );
}


AddWizard.propTypes = {
  userInfo: PropTypes.object.isRequired,
  items: PropTypes.object.isRequired,
  itemCharacteristics: PropTypes.object.isRequired,
  intl: PropTypes.object.isRequired,
  enqueueSnackbar: PropTypes.func.isRequired,
  closeSnackbar: PropTypes.func.isRequired,
  classes: PropTypes.object.isRequired,
}

export default injectIntl(withSnackbar(withItems(withItemCharacteristics(withUserInfo(withStyles(styles, { withTheme: true })(AddWizard))))));







  